<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypt</title>
    <link href="https://fonts.cdnfonts.com/css/matrixtype" rel="stylesheet">
    <style>
        @import url('https://fonts.cdnfonts.com/css/matrixtype');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #c0c0c0;
            min-height: 100vh;
            padding: 40px 20px;
            overflow-y: auto;
            position: relative;
        }
        
        /* Matrix Rain Background */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }
        
        .matrix-column {
            position: absolute;
            top: -100%;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ff41;
            opacity: 0.15;
            animation: matrix-fall linear infinite;
            text-shadow: 0 0 5px #00ff41;
        }
        
        @keyframes matrix-fall {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(200vh);
            }
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px;
            position: relative;
            z-index: 1;
        }
        
        header {
            text-align: center;
            margin-bottom: 60px;
            padding: 40px 0;
        }
        
        h1 {
            font-family: 'matrixtype', 'Courier New', monospace;
            font-size: 5em;
            color: #00ff41;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-weight: 400;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
        }
        
        .tagline {
            font-size: 0.9em;
            color: #c0c0c0;
            margin-top: 15px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }
        
        .section {
            margin-bottom: 50px;
        }
        
        h2 {
            color: #ffffff;
            font-size: 0.9em;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 25px;
            font-weight: normal;
        }
        
        p {
            line-height: 1.8;
            color: #c0c0c0;
        }
        
        .formula {
            background: #0f0f0f;
            padding: 15px 25px;
            margin: 15px 0;
            border-left: 2px solid #ffffff;
            font-family: 'Courier New', monospace;
            color: #ffffff;
            font-size: 1em;
        }
        
        /* Tool Section */
        .tool-container {
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            padding: 30px;
            margin-top: 40px;
        }
        
        .input-group {
            margin-bottom: 25px;
        }
        
        .input-group label {
            display: block;
            color: #c0c0c0;
            font-size: 0.8em;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .input-group input,
        .input-group textarea {
            width: 100%;
            background: #0a0a0a;
            border: 1px solid #252525;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            padding: 15px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus,
        .input-group textarea:focus {
            border-color: #00ff41;
        }
        
        .input-group textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 600px) {
            .input-row {
                grid-template-columns: 1fr;
            }
        }
        
        .btn {
            background: transparent;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            background: #00ff41;
            color: #0a0a0a;
        }
        
        .btn-small {
            padding: 8px 15px;
            font-size: 0.75em;
            border-color: #606060;
            color: #c0c0c0;
        }
        
        .btn-small:hover {
            border-color: #00ff41;
            color: #00ff41;
            background: transparent;
        }
        
        .xor-display {
            background: #0a0a0a;
            border: 1px solid #252525;
            padding: 20px;
            margin: 10px 0;
            min-height: 50px;
            color: #ffffff;
            font-size: 0.9em;
            word-break: break-all;
        }
        
        .xor-display .text-line {
            color: #707070;
            font-size: 0.85em;
            margin-bottom: 10px;
        }
        
        .xor-display .binary-line {
            color: #00ff41;
            font-size: 1.1em;
            letter-spacing: 0.05em;
        }
        
        .xor-display.empty {
            color: #808080;
        }
        
        .crib-binary {
            margin-top: 10px;
            padding: 10px 15px;
            background: #0a0a0a;
            border: 1px solid #252525;
            color: #00ff41;
            font-size: 1em;
            letter-spacing: 0.05em;
            min-height: 20px;
        }
        
        .crib-binary:empty {
            display: none;
        }
        
        /* XOR Operation Display */
        .xor-operation {
            background: #0a0a0a;
            border: 1px solid #252525;
            padding: 25px;
            margin-top: 25px;
            font-family: 'Courier New', monospace;
        }
        
        .op-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
        }
        
        .op-label {
            color: #707070;
            min-width: 80px;
            font-size: 0.9em;
        }
        
        .op-binary {
            color: #00ff41;
            flex: 1;
            font-size: 1em;
            letter-spacing: 0.05em;
        }
        
        .op-text {
            color: #ffffff;
            min-width: 100px;
            text-align: right;
            font-size: 1.1em;
            letter-spacing: 0.1em;
        }
        
        .op-divider {
            border-top: 1px solid #00ff41;
            margin: 10px 0;
        }
        
        .op-row.result .op-binary {
            color: #ffffff;
        }
        
        .op-row.result .op-text {
            color: #00ff41;
            font-size: 1.3em;
        }
        
        /* Position Slider */
        .position-control {
            margin: 20px 0;
            padding: 15px;
            background: #0a0a0a;
            border: 1px solid #252525;
        }
        
        .position-control label {
            display: block;
            color: #707070;
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .position-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: #252525;
            outline: none;
            border-radius: 2px;
        }
        
        .position-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .position-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .position-value {
            color: #00ff41;
            font-size: 1.2em;
            min-width: 50px;
            text-align: center;
        }
        
        /* Results Table */
        .results-section {
            margin-top: 25px;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .results-header label {
            color: #c0c0c0;
            font-size: 0.85em;
        }
        
        .filter-toggle {
            display: flex;
            gap: 10px;
        }
        
        .filter-btn {
            background: transparent;
            border: 1px solid #303030;
            color: #606060;
            padding: 5px 12px;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .filter-btn.active {
            border-color: #00ff41;
            color: #00ff41;
        }
        
        .results-table {
            background: #0a0a0a;
            border: 1px solid #252525;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .result-row {
            display: grid;
            grid-template-columns: 50px 1fr 1fr 80px;
            padding: 10px 15px;
            border-bottom: 1px solid #151515;
            font-size: 0.85em;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .result-row:hover {
            background: #151515;
        }
        
        .result-row.selected {
            background: rgba(0, 255, 65, 0.1);
            border-left: 2px solid #00ff41;
        }
        
        .result-row.readable {
            background: rgba(0, 255, 65, 0.05);
        }
        
        .result-row .pos {
            color: #505050;
        }
        
        .result-row .p2-result {
            color: #ffffff;
            font-family: 'Courier New', monospace;
        }
        
        .result-row .p1-result {
            color: #707070;
            font-family: 'Courier New', monospace;
        }
        
        .result-row .score {
            color: #505050;
            text-align: right;
        }
        
        .result-row.readable .score {
            color: #00ff41;
        }

        /* Decrypted view */
        .decrypted-view {
            margin-top: 18px;
            padding: 18px;
            background: #0a0a0a;
            border: 1px solid #252525;
            font-family: 'Courier New', monospace;
            color: #c0c0c0;
            line-height: 1.8;
            min-height: 46px;
        }

        .decrypted-line {
            white-space: pre-wrap;
            word-break: keep-all;
        }

        .highlight-match {
            background: rgba(0,255,65,0.12);
            color: #ffffff;
            padding: 0 2px;
            border-radius: 2px;
        }
        
        .result-row-header {
            display: grid;
            grid-template-columns: 50px 1fr 1fr 80px;
            padding: 8px 15px;
            background: #0f0f0f;
            border-bottom: 1px solid #252525;
            font-size: 0.7em;
            color: #505050;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .cribs-bar {
            margin: 20px 0;
        }
        
        .cribs-bar span {
            color: #909090;
            font-size: 0.75em;
            margin-right: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .status-line {
            color: #404040;
            font-size: 0.8em;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #1a1a1a;
        }
        
        .status-line.success {
            color: #ffffff;
        }
        
        .status-line.error {
            color: #ff4444;
        }
        
        /* Info Panel */
        .info-panel {
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            padding: 25px;
            margin-bottom: 40px;
        }
        
        .info-panel h3 {
            color: #00ff41;
            font-size: 0.85em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 15px;
            font-weight: normal;
        }
        
        .info-panel p {
            font-size: 0.9em;
            line-height: 1.7;
            margin-bottom: 12px;
        }
        
        .info-panel .highlight {
            color: #00ff41;
        }
        
        .info-panel .warning {
            color: #ff4444;
        }
        
        .key-insight {
            background: #0a0a0a;
            border-left: 2px solid #00ff41;
            padding: 15px 20px;
            margin: 15px 0;
            font-size: 0.9em;
        }
        
        .key-insight strong {
            color: #ffffff;
        }
        
        .step-indicator {
            display: inline-block;
            background: #00ff41;
            color: #0a0a0a;
            width: 22px;
            height: 22px;
            line-height: 22px;
            text-align: center;
            font-size: 0.75em;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .footer-note {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #1a1a1a;
            font-size: 0.75em;
            color: #505050;
            text-align: center;
        }
        
        .footer-note a {
            color: #707070;
            text-decoration: none;
        }
        
        .footer-note a:hover {
            color: #00ff41;
        }
        
        ::selection {
            background: #00ff41;
            color: #000;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #252525;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #00ff41;
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Background -->
    <div class="matrix-bg" id="matrixBg"></div>
    
    <div class="container">
        <header>
            <h1>Crypt</h1>
            <p class="tagline">Two-Time Pad Cryptanalysis</p>
        </header>
        
        <div class="info-panel">
            <h3>The Vulnerability</h3>
            <p>A <span class="highlight">one-time pad</span> is unbreakable — but only if the key is <strong>never reused</strong>. When the same key encrypts two messages, the XOR of the ciphertexts <span class="warning">cancels out the key entirely</span>:</p>
            <div class="formula">C₁ ⊕ C₂ = (P₁ ⊕ K) ⊕ (P₂ ⊕ K) = P₁ ⊕ P₂</div>
            <div class="key-insight">
                <strong>Key Insight:</strong> The result is the XOR of the two plaintexts. If you know (or guess) one message, you can recover the other.
            </div>
            <p style="font-size: 0.85em; color: #707070;">This technique broke Soviet intelligence communications in the <span class="highlight">Venona Project</span> (1943-1980) when pad pages were accidentally reused.</p>
        </div>
        
        <div class="tool-container">
            <h2>Crib-Dragging Attack</h2>
            
            <div class="input-group">
                <label><span class="step-indicator">1</span>Intercepted Ciphertexts (5-bit Baudot binary)</label>
            </div>
            <div class="input-row">
                <div class="input-group">
                    <label style="font-size: 0.7em; color: #505050;">C₁ = P₁ ⊕ K</label>
                    <textarea id="c1" placeholder="00000 11111 11001 11000 10111 00011"></textarea>
                </div>
                <div class="input-group">
                    <label style="font-size: 0.7em; color: #505050;">C₂ = P₂ ⊕ K</label>
                    <textarea id="c2" placeholder="00000 01011 00100 01001 11111 00011"></textarea>
                </div>
            </div>
            
            <button class="btn" onclick="computeXOR()">XOR Ciphertexts → Remove Key</button>
            
            <div class="input-group" style="margin-top: 25px;">
                <label><span class="step-indicator">2</span>Key Eliminated: P₁ ⊕ P₂</label>
                <div class="xor-display empty" id="xorDisplay">Waiting for input...</div>
            </div>
            
            <div class="input-group">
                <label><span class="step-indicator">3</span>Enter Known Plaintext (Crib)</label>
                <input type="text" id="crib" placeholder="Guess a word from one message..." oninput="updateCribBinary()">
                <div class="crib-binary" id="cribBinary"></div>
            </div>
            
            <div class="cribs-bar">
                <span>Common cribs:</span>
                <button class="btn btn-small" onclick="useCrib('THE ')">THE_</button>
                <button class="btn btn-small" onclick="useCrib(' AND ')">_AND_</button>
                <button class="btn btn-small" onclick="useCrib('ATTACK')">ATTACK</button>
                <button class="btn btn-small" onclick="useCrib('SECRET')">SECRET</button>
                <button class="btn btn-small" onclick="useCrib('CIPHER')">CIPHER</button>
                <button class="btn btn-small" onclick="useCrib('CAESAR')">CAESAR</button>
            </div>
            
            <!-- Position Slider -->
            <div class="position-control" id="positionControl" style="display: none;">
                <label>Drag Position (slide crib across the XOR stream)</label>
                <div class="slider-row">
                    <span class="position-value" id="posValue">0</span>
                    <input type="range" class="position-slider" id="posSlider" min="0" max="0" value="0" oninput="updatePosition()">
                    <span style="color: #505050; font-size: 0.8em;">max: <span id="maxPos">0</span></span>
                </div>
            </div>
            
            <!-- XOR Operation Display -->
            <div class="xor-operation" id="xorOperation" style="display: none;">
                <label style="display: block; margin-bottom: 15px;"><span class="step-indicator">4</span>XOR at Position <span id="currentPosLabel">0</span></label>
                <div class="op-row">
                    <span class="op-label">P₁ ⊕ P₂</span>
                    <span class="op-binary" id="opXorStream"></span>
                    <span class="op-text" id="opXorText"></span>
                </div>
                <div class="op-row">
                    <span class="op-label">⊕ Crib</span>
                    <span class="op-binary" id="opCribBin"></span>
                    <span class="op-text" id="opCribText"></span>
                </div>
                <div class="op-divider"></div>
                <div class="op-row result">
                    <span class="op-label">= P₂</span>
                    <span class="op-binary" id="opResultBin"></span>
                    <span class="op-text" id="opResultText"></span>
                </div>
            </div>
            
            <!-- Decrypted plaintext view (contextual) -->
            <div class="decrypted-view" id="decryptedView" style="display: none;">
                <div style="font-size:0.8em;color:#707070;margin-bottom:8px;">Decrypted context (inferred from crib at selected position)</div>
                <div class="decrypted-line" id="decryptedLine"></div>
            </div>
            
            <!-- Persistent recovered buffers -->
            <div class="decrypted-view" id="recoveredView" style="display: none;">
                <div style="font-size:0.8em;color:#707070;margin-bottom:8px;">Recovered plaintext buffers (accumulated from accepted matches)</div>
                <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px;">
                    <div style="flex:1">
                        <div style="font-size:0.75em;color:#707070;margin-bottom:6px;">P₁ (accepted)</div>
                        <div class="decrypted-line" id="recoveredP1"></div>
                    </div>
                    <div style="flex:1">
                        <div style="font-size:0.75em;color:#707070;margin-bottom:6px;">P₂ (accepted)</div>
                        <div class="decrypted-line" id="recoveredP2"></div>
                    </div>
                </div>
                <div style="display:flex;gap:12px;align-items:center;">
                    <button class="btn btn-small" onclick="applyRecovery('p2')">Accept current → P₂</button>
                    <button class="btn btn-small" onclick="applyRecovery('p1')">Accept current → P₁</button>
                    <button class="btn btn-small" onclick="clearRecovered()" style="border-color:#252525;">Clear Recovered</button>
                </div>
            </div>
            
            <!-- All Positions Results -->
            <div class="results-section" id="resultsSection" style="display: none;">
                <div class="results-header">
                    <label><span class="step-indicator">5</span>All Positions (click to select)</label>
                    <div class="filter-toggle">
                        <button class="filter-btn active" id="filterAll" onclick="setFilter('all')">All</button>
                        <button class="filter-btn" id="filterReadable" onclick="setFilter('readable')">Readable Only</button>
                    </div>
                </div>
                <div class="result-row-header">
                    <span>Pos</span>
                    <span>If crib = P₁ → P₂</span>
                    <span>If crib = P₂ → P₁</span>
                    <span>Score</span>
                </div>
                <div class="results-table" id="resultsTable"></div>
            </div>
            
            <div class="status-line" id="status">Ready</div>
        </div>
        
        <div class="footer-note">
            Historical: The <a href="https://en.wikipedia.org/wiki/Venona_project" target="_blank">Venona Project</a> used this exact technique to decrypt 3,000+ Soviet intelligence messages (1943–1980)
        </div>
    </div>
    
    <script>
        // Baudot/ITA2 encoding (standard 5-bit)
        const CHAR_TO_BIN = {
            '/': '00000', 'E': '10000', 'A': '11000', 'S': '10100', 'I': '01100',
            'U': '11100', 'D': '10010', 'R': '01010', 'J': '11010', 'N': '00110',
            'F': '10110', 'C': '01110', 'K': '11110', 'T': '00001', 'Z': '10001',
            'L': '01001', 'W': '11001', 'H': '00101', 'Y': '10101', 'P': '01101',
            'Q': '11101', 'O': '00011', 'B': '10011', 'G': '01011', 'M': '00111',
            'X': '10111', 'V': '01111', ' ': '00100', '3': '01000', '4': '00010',
            '5': '11011', '8': '10110', '9': '11111'
        };
        
        const BIN_TO_CHAR = Object.fromEntries(
            Object.entries(CHAR_TO_BIN).map(([k, v]) => [v, k])
        );
        
        let xorStream = '';
        let bin1_global = '';
        let bin2_global = '';
        let currentPosition = 0;
        let allResults = [];
        let filterMode = 'all';
        let recoveredP1 = [];
        let recoveredP2 = [];
        
        function cleanBinary(input) {
            const cleaned = input.replace(/\s/g, '');
            if (!/^[01]+$/.test(cleaned)) {
                throw new Error('Invalid binary: only 0 and 1 allowed');
            }
            return cleaned;
        }
        
        function xorBinary(a, b) {
            const maxLen = Math.max(a.length, b.length);
            a = a.padStart(maxLen, '0');
            b = b.padStart(maxLen, '0');
            let result = '';
            for (let i = 0; i < maxLen; i++) {
                result += a[i] === b[i] ? '0' : '1';
            }
            return result;
        }
        
        function binaryToText(binary) {
            let text = '';
            for (let i = 0; i < binary.length; i += 5) {
                const chunk = binary.substr(i, 5);
                if (chunk.length === 5) {
                    text += BIN_TO_CHAR[chunk] || '?';
                }
            }
            return text;
        }
        
        function textToBinary(text) {
            let binary = '';
            for (const char of text.toUpperCase()) {
                binary += CHAR_TO_BIN[char] || '00000';
            }
            return binary;
        }
        
        function formatBinary(binary) {
            let formatted = '';
            for (let i = 0; i < binary.length; i += 5) {
                if (i > 0) formatted += ' ';
                formatted += binary.substr(i, 5);
            }
            return formatted;
        }
        
        // Improved readability scoring
        function scoreReadability(text) {
            if (text.length < 2) return 0;
            const letters = (text.match(/[A-Z]/g) || []).length;
            const spaces = (text.match(/ /g) || []).length;
            const common = (text.match(/[ETAOINSHRDLU ]/gi) || []).length;
            const special = (text.match(/[\/?34589]/g) || []).length;
            
            let score = 0;
            score += (letters / text.length) * 40;  // Letter ratio
            score += (common / text.length) * 30;   // Common letter ratio
            score += (spaces / text.length) * 20;   // Space ratio (natural text has spaces)
            score -= (special / text.length) * 20;  // Penalize special chars
            
            return Math.max(0, Math.min(100, Math.round(score)));
        }
        
        function isReadable(text) {
            return scoreReadability(text) >= 50;
        }
        
        function computeXOR() {
            const c1 = document.getElementById('c1').value.trim();
            const c2 = document.getElementById('c2').value.trim();
            
            if (!c1 || !c2) {
                setStatus('Enter both ciphertexts', false);
                return;
            }
            
            try {
                const bin1 = cleanBinary(c1);
                const bin2 = cleanBinary(c2);
                
                if (bin1.length !== bin2.length) {
                    setStatus(`Length mismatch: ${bin1.length} vs ${bin2.length} bits`, false);
                    return;
                }
                
                xorStream = xorBinary(bin1, bin2);
                bin1_global = bin1;
                bin2_global = bin2;

                // initialize recovered buffers
                const totalChars = Math.floor(xorStream.length / 5);
                recoveredP1 = new Array(totalChars).fill(null);
                recoveredP2 = new Array(totalChars).fill(null);
                
                const decoded = binaryToText(xorStream);
                const display = document.getElementById('xorDisplay');
                display.innerHTML = `<div class="text-line">${decoded}</div><div class="binary-line">${formatBinary(xorStream)}</div>`;
                display.classList.remove('empty');
                
                updateCribBinary();
                setStatus(`XOR computed: ${Math.floor(xorStream.length / 5)} characters. Enter a crib to begin dragging.`, true);
            } catch (e) {
                setStatus(e.message, false);
            }
        }
        
        function updateCribBinary() {
            const crib = document.getElementById('crib').value.trim().toUpperCase();
            const cribBinaryEl = document.getElementById('cribBinary');
            const posControl = document.getElementById('positionControl');
            const xorOp = document.getElementById('xorOperation');
            const resultsSection = document.getElementById('resultsSection');
            
            if (!crib) {
                cribBinaryEl.textContent = '';
                posControl.style.display = 'none';
                xorOp.style.display = 'none';
                resultsSection.style.display = 'none';
                return;
            }
            
            const cribBin = textToBinary(crib);
            cribBinaryEl.textContent = formatBinary(cribBin);
            
            if (xorStream && cribBin.length <= xorStream.length) {
                const maxPos = Math.floor((xorStream.length - cribBin.length) / 5);
                
                // Setup slider
                const slider = document.getElementById('posSlider');
                slider.max = maxPos;
                document.getElementById('maxPos').textContent = maxPos;
                posControl.style.display = 'block';
                
                // Compute all results
                computeAllPositions(cribBin);
                
                // Update display for current position
                updatePosition();
                
                resultsSection.style.display = 'block';
                renderResults();
            } else {
                posControl.style.display = 'none';
                xorOp.style.display = 'none';
                resultsSection.style.display = 'none';
            }
        }
        
        function computeAllPositions(cribBin) {
            allResults = [];
            const maxPos = Math.floor((xorStream.length - cribBin.length) / 5) + 1;
            
            for (let pos = 0; pos < maxPos; pos++) {
                const bitPos = pos * 5;
                const portion = xorStream.substr(bitPos, cribBin.length);
                const resultBin = xorBinary(portion, cribBin);
                const p2Result = binaryToText(resultBin);  // If crib is P1
                const p1Result = binaryToText(resultBin);  // If crib is P2 (same XOR, symmetric)
                
                const score = Math.max(scoreReadability(p2Result), scoreReadability(p1Result));
                
                allResults.push({
                    pos,
                    portion,
                    resultBin,
                    p2Result,
                    p1Result,
                    score,
                    readable: score >= 50
                });
            }
            
            // Sort by score for quick identification
            const readableCount = allResults.filter(r => r.readable).length;
            setStatus(`Found ${readableCount} potentially readable results out of ${allResults.length} positions`, readableCount > 0);
        }
        
        function updatePosition() {
            const pos = parseInt(document.getElementById('posSlider').value);
            currentPosition = pos;
            document.getElementById('posValue').textContent = pos;
            document.getElementById('currentPosLabel').textContent = pos;
            
            const crib = document.getElementById('crib').value.trim().toUpperCase();
            const cribBin = textToBinary(crib);
            
            if (allResults[pos]) {
                const r = allResults[pos];

                document.getElementById('opXorStream').textContent = formatBinary(r.portion);
                document.getElementById('opXorText').textContent = binaryToText(r.portion);
                document.getElementById('opCribBin').textContent = formatBinary(cribBin);
                document.getElementById('opCribText').textContent = crib;
                document.getElementById('opResultBin').textContent = formatBinary(r.resultBin);
                document.getElementById('opResultText').textContent = r.p2Result;

                document.getElementById('xorOperation').style.display = 'block';

                // Highlight selected row in results
                document.querySelectorAll('.result-row').forEach((row, i) => {
                    row.classList.toggle('selected', parseInt(row.dataset.pos) === pos);
                });

                // Render decrypted view (show contextual P2 with highlighted match)
                renderDecryptedView(pos, cribBin.length / 5);
            }
        }

        // Render a contextual decrypted view for P2 using the inferred segment
        function renderDecryptedView(posChars, cribChars) {
            // total characters in stream
            const totalChars = Math.floor(xorStream.length / 5);
            const viewEl = document.getElementById('decryptedView');
            const lineEl = document.getElementById('decryptedLine');

            if (!bin2_global) {
                viewEl.style.display = 'none';
                return;
            }

            // copy placeholder array
            const chars = new Array(totalChars).fill('·');

            // compute bit positions
            const startBit = posChars * 5;
            const cribBitLen = cribChars * 5;

            // get crib binary and result
            const crib = document.getElementById('crib').value.trim().toUpperCase();
            const cribBin = textToBinary(crib);

            const portion = xorStream.substr(startBit, cribBin.length);
            const resultBin = xorBinary(portion, cribBin);
            const resultText = binaryToText(resultBin);

            // fill the resultText into chars array at positions
            for (let i = 0; i < resultText.length; i++) {
                chars[posChars + i] = resultText[i] || '?';
            }

            // build HTML with highlighted span for matched region
            let html = '';
            for (let i = 0; i < chars.length; i++) {
                if (i >= posChars && i < posChars + resultText.length) {
                    html += `<span class="highlight-match">${chars[i]}</span>`;
                } else {
                    html += chars[i];
                }
                // add a small spacer for readability
                if ((i + 1) % 10 === 0) html += ' ';
            }

            lineEl.innerHTML = html;
            viewEl.style.display = 'block';
        }
        
        function renderResults() {
            const table = document.getElementById('resultsTable');
            table.innerHTML = '';
            
            const filtered = filterMode === 'readable' 
                ? allResults.filter(r => r.readable)
                : allResults;
            
            filtered.forEach(r => {
                const row = document.createElement('div');
                row.className = 'result-row' + (r.readable ? ' readable' : '') + (r.pos === currentPosition ? ' selected' : '');
                row.dataset.pos = r.pos;
                row.onclick = () => selectPosition(r.pos);
                row.innerHTML = `
                    <span class="pos">${r.pos.toString().padStart(2, '0')}</span>
                    <span class="p2-result">${r.p2Result}</span>
                    <span class="p1-result">${r.p1Result}</span>
                    <span class="score">${r.score}%</span>
                `;
                table.appendChild(row);
            });
            // show recovered view if there is any data
            const hasRecovered = (recoveredP1 && recoveredP1.some(Boolean)) || (recoveredP2 && recoveredP2.some(Boolean));
            document.getElementById('recoveredView').style.display = hasRecovered ? 'block' : 'none';
        }
        
        function selectPosition(pos) {
            document.getElementById('posSlider').value = pos;
            updatePosition();
        }
        
        function setFilter(mode) {
            filterMode = mode;
            document.getElementById('filterAll').classList.toggle('active', mode === 'all');
            document.getElementById('filterReadable').classList.toggle('active', mode === 'readable');
            renderResults();
        }
        
        function useCrib(crib) {
            document.getElementById('crib').value = crib;
            updateCribBinary();
        }

        // Accept current result at selected position into recovered buffers
        function applyRecovery(target) {
            // target = 'p1' or 'p2'
            if (!allResults[currentPosition]) return;
            const r = allResults[currentPosition];
            const resultText = r.p2Result || '';
            const len = resultText.length;

            if (target === 'p2') {
                for (let i = 0; i < len; i++) {
                    recoveredP2[currentPosition + i] = resultText[i] || recoveredP2[currentPosition + i];
                }
            } else {
                for (let i = 0; i < len; i++) {
                    recoveredP1[currentPosition + i] = resultText[i] || recoveredP1[currentPosition + i];
                }
            }
            renderRecoveredBuffers();
            setStatus(`Accepted ${len} chars into ${target.toUpperCase()}`, true);
        }

        function renderRecoveredBuffers() {
            const total = Math.floor(xorStream.length / 5) || 0;
            const p1el = document.getElementById('recoveredP1');
            const p2el = document.getElementById('recoveredP2');
            if (total === 0) {
                p1el.textContent = '';
                p2el.textContent = '';
                document.getElementById('recoveredView').style.display = 'none';
                return;
            }

            let html1 = '';
            let html2 = '';
            for (let i = 0; i < total; i++) {
                const c1 = recoveredP1[i] || '·';
                const c2 = recoveredP2[i] || '·';
                html1 += (recoveredP1[i]) ? `<span class="highlight-match">${c1}</span>` : c1;
                html2 += (recoveredP2[i]) ? `<span class="highlight-match">${c2}</span>` : c2;
                if ((i + 1) % 10 === 0) { html1 += ' '; html2 += ' '; }
            }
            p1el.innerHTML = html1;
            p2el.innerHTML = html2;
            document.getElementById('recoveredView').style.display = 'block';
        }

        function clearRecovered() {
            recoveredP1 = recoveredP1.map(() => null);
            recoveredP2 = recoveredP2.map(() => null);
            renderRecoveredBuffers();
            setStatus('Recovered buffers cleared', false);
        }
        
        function setStatus(msg, success) {
            const status = document.getElementById('status');
            status.textContent = msg;
            status.className = 'status-line' + (success === true ? ' success' : (success === false ? ' error' : ''));
        }
        
        // Matrix Rain Effect
        function createMatrixRain() {
            const container = document.getElementById('matrixBg');
            const columns = Math.floor(window.innerWidth / 20);
            
            for (let i = 0; i < columns; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = (i * 20) + 'px';
                column.style.animationDuration = (Math.random() * 10 + 10) + 's';
                column.style.animationDelay = (Math.random() * 10) + 's';
                
                let binary = '';
                const length = Math.floor(Math.random() * 20) + 10;
                for (let j = 0; j < length; j++) {
                    binary += Math.random() > 0.5 ? '1' : '0';
                    binary += '<br>';
                }
                column.innerHTML = binary;
                container.appendChild(column);
            }
        }
        
        window.addEventListener('load', createMatrixRain);
    </script>
</body>
</html>
